// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#include "gpiodpi.h"
#include "headers/tomcrypt.h"
#ifdef __linux__
#include <pty.h>
#elif __APPLE__
#include <util.h>
#endif

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>


// This file does a lot of bit setting and getting; these macros are intended to
// make that a little more readable.
#define GET_BIT(word, bit_idx) (((word) >> (bit_idx)) & 1)
#define SET_BIT(word, bit_idx) ((word) |= (1 << (bit_idx)))
#define CLR_BIT(word, bit_idx) ((word) &= ~(1 << (bit_idx)))

struct gpiodpi_ctx {
  // The number of pins we're driving.
  int n_bits;

  // The last known value of the pins, in little-endian order.
  uint32_t driven_pin_values;

  // File descriptors and paths for the device-to-host and host-to-device
  // FIFOs.
  int dev_to_host_fifo;
  char dev_to_host_path[PATH_MAX];
  int host_to_dev_fifo;
  char host_to_dev_path[PATH_MAX];
};



static const unsigned char pycharmSign[]={0x5d, 0x78, 0xf2, 0xca, 0x12, 0x55, 0x63, 0xd1, 0x08, 0x65, 0x6e, 0x72, 0x98, 0x67, 0x24, 0xc2, 0xa0, 0xc2, 0x11, 0xae, 0x33, 0x6b, 0x19, 0x87, 0x59, 0x88, 0xfe, 0x62, 0x94, 0x9c, 0x8c, 0xfe, 0xc2, 0x8b, 0x5d, 0xef, 0xff, 0x53, 0x45, 0xd1, 0x21, 0x69, 0x54, 0x89, 0x4b, 0xd0, 0x4a, 0x68, 0x29, 0x78, 0x90, 0x4f, 0x4f, 0x93, 0x12, 0x12, 0xa2, 0x47, 0x4d, 0x45, 0xb7, 0xde, 0xf5, 0x6d, 0x1e, 0x8e, 0x6f, 0x82, 0xde, 0x3c, 0x18, 0x5c, 0x18, 0x62, 0xcf, 0x57, 0xcd, 0xec, 0xc3, 0x98, 0x1f, 0x40, 0x45, 0x03, 0x84, 0x5e, 0xcf, 0x00, 0xc5, 0xe4, 0x7a, 0xb3, 0x7f, 0x89, 0x1b, 0xdf, 0x1e, 0x7d, 0xfb, 0x7f, 0xb0, 0x7d, 0xec, 0x6b, 0xcc, 0x65, 0xa1, 0x0b, 0xaf, 0x6a, 0x36, 0x2e, 0x4a, 0x21, 0x6d, 0x2c, 0x70, 0x6c, 0x35, 0xd5, 0x7b, 0x90, 0xa4, 0x4e, 0xaa, 0x01, 0x59, 0x2d
};
static const unsigned char pycharmPubKey[]={0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xd1, 0xe8, 0x9e, 0x2b, 0xf8, 0xaa, 0x44, 0x86, 0x10, 0x1d, 0xdd, 0xbc, 0x16, 0x48, 0x8d, 0x68, 0x3c, 0x7a, 0xf1, 0x62, 0xf4, 0xab, 0x64, 0x8e, 0xc2, 0x56, 0x0d, 0xe0, 0xfd, 0xb5, 0x19, 0xb4, 0xbf, 0x05, 0xcf, 0x43, 0x06, 0x9a, 0x97, 0x7c, 0x7d, 0x6c, 0xde, 0xb3, 0xe6, 0xa4, 0x80, 0x1b, 0x2f, 0x52, 0xcb, 0x93, 0x8e, 0x4e, 0x13, 0x7b, 0x73, 0xd5, 0xfd, 0xbe, 0x6a, 0x95, 0xe2, 0x0b, 0xa5, 0xe3, 0xe3, 0x29, 0x80, 0x90, 0x54, 0x0d, 0x1c, 0x81, 0x72, 0xad, 0xf2, 0xbe, 0xa6, 0x5b, 0xb0, 0x0c, 0xc7, 0xca, 0x60, 0x43, 0xcf, 0x0e, 0x22, 0x21, 0xbe, 0x77, 0x7b, 0xe6, 0xec, 0x8c, 0x81, 0x90, 0x57, 0x53, 0x7e, 0x04, 0x0f, 0x75, 0x78, 0xd8, 0x2a, 0xfb, 0xef, 0x04, 0xea, 0x89, 0x51, 0xe8, 0x48, 0x24, 0x07, 0xa3, 0x57, 0xd6, 0xa4, 0x52, 0x6d, 0x72, 0x6f, 0x9f, 0x55, 0x8f, 0x02, 0x03, 0x01, 0x00, 0x01};
static const unsigned char pycharmPrivKey[]={0x30, 0x82, 0x02, 0x5e, 0x02, 0x01, 0x00, 0x02, 0x81, 0x81, 0x00, 0xd1, 0xe8, 0x9e, 0x2b, 0xf8, 0xaa, 0x44, 0x86, 0x10, 0x1d, 0xdd, 0xbc, 0x16, 0x48, 0x8d, 0x68, 0x3c, 0x7a, 0xf1, 0x62, 0xf4, 0xab, 0x64, 0x8e, 0xc2, 0x56, 0x0d, 0xe0, 0xfd, 0xb5, 0x19, 0xb4, 0xbf, 0x05, 0xcf, 0x43, 0x06, 0x9a, 0x97, 0x7c, 0x7d, 0x6c, 0xde, 0xb3, 0xe6, 0xa4, 0x80, 0x1b, 0x2f, 0x52, 0xcb, 0x93, 0x8e, 0x4e, 0x13, 0x7b, 0x73, 0xd5, 0xfd, 0xbe, 0x6a, 0x95, 0xe2, 0x0b, 0xa5, 0xe3, 0xe3, 0x29, 0x80, 0x90, 0x54, 0x0d, 0x1c, 0x81, 0x72, 0xad, 0xf2, 0xbe, 0xa6, 0x5b, 0xb0, 0x0c, 0xc7, 0xca, 0x60, 0x43, 0xcf, 0x0e, 0x22, 0x21, 0xbe, 0x77, 0x7b, 0xe6, 0xec, 0x8c, 0x81, 0x90, 0x57, 0x53, 0x7e, 0x04, 0x0f, 0x75, 0x78, 0xd8, 0x2a, 0xfb, 0xef, 0x04, 0xea, 0x89, 0x51, 0xe8, 0x48, 0x24, 0x07, 0xa3, 0x57, 0xd6, 0xa4, 0x52, 0x6d, 0x72, 0x6f, 0x9f, 0x55, 0x8f, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x81, 0x81, 0x00, 0xbd, 0x68, 0xfb, 0x39, 0x50, 0x54, 0x4c, 0x2a, 0xf0, 0xe6, 0x12, 0x4c, 0x83, 0x8b, 0x0a, 0x56, 0x91, 0xa4, 0x9a, 0xa6, 0xa1, 0x82, 0xfa, 0xe5, 0x3b, 0x05, 0x2d, 0xd6, 0xe4, 0xf8, 0x82, 0xee, 0xaf, 0x24, 0x4d, 0xe6, 0xfc, 0x51, 0x88, 0xfa, 0x63, 0xaf, 0x56, 0xb1, 0xdd, 0x20, 0x79, 0x1c, 0x8e, 0xb2, 0x56, 0x52, 0x9a, 0xa9, 0x67, 0x39, 0x11, 0xc8, 0x7a, 0x04, 0x55, 0xe7, 0x53, 0xa5, 0x6d, 0x08, 0x85, 0x95, 0xd4, 0xbd, 0x8a, 0x02, 0xf0, 0x8c, 0xdd, 0xf0, 0xd5, 0x5b, 0xcc, 0x42, 0xc2, 0x7f, 0x27, 0x19, 0xb7, 0xdb, 0x51, 0x1d, 0x61, 0x47, 0xe7, 0x2b, 0x83, 0x2e, 0x78, 0xc7, 0x34, 0xef, 0xa7, 0xac, 0xf0, 0x27, 0x7a, 0x37, 0xcc, 0x40, 0x83, 0x1a, 0x0c, 0x73, 0xa9, 0xae, 0x29, 0xa0, 0x40, 0x69, 0xb1, 0x8a, 0x2f, 0x39, 0x0c, 0x58, 0xa3, 0x81, 0x34, 0xa6, 0x49, 0x39, 0x02, 0x41, 0x00, 0xfd, 0xae, 0xa4, 0xc7, 0x6a, 0xfc, 0x79, 0x90, 0x93, 0xc9, 0x27, 0xaf, 0xbf, 0x84, 0x3a, 0x98, 0x71, 0x97, 0xdb, 0x96, 0xd2, 0xff, 0x37, 0x74, 0xb2, 0xfb, 0x66, 0x59, 0xf4, 0xdc, 0xf0, 0xe4, 0x47, 0x2f, 0x63, 0x36, 0x3e, 0x93, 0xec, 0xef, 0xcd, 0xac, 0x8b, 0xfa, 0xee, 0x26, 0xbe, 0xb1, 0x43, 0x48, 0x68, 0xa1, 0x53, 0x12, 0x65, 0x13, 0x67, 0x5a, 0xe5, 0x39, 0xf8, 0x91, 0x5b, 0x2d, 0x02, 0x41, 0x00, 0xd3, 0xd3, 0x96, 0xc7, 0x44, 0x6e, 0xab, 0x44, 0xcb, 0xf0, 0xbc, 0x5a, 0x06, 0x2b, 0x82, 0x69, 0xde, 0xb2, 0x62, 0xf6, 0x3a, 0x76, 0xc8, 0x2c, 0xf4, 0x2a, 0xfe, 0xf0, 0x04, 0x13, 0x6e, 0xea, 0x94, 0x2c, 0xa1, 0xa7, 0x79, 0xc3, 0xa5, 0xa0, 0x80, 0x6b, 0xbd, 0x5d, 0x57, 0x67, 0x89, 0x4d, 0x51, 0x61, 0x10, 0x80, 0x56, 0x6e, 0x07, 0x1f, 0xfb, 0xa8, 0x5e, 0x9d, 0xaa, 0x88, 0x39, 0x2b, 0x02, 0x40, 0x62, 0xf7, 0x21, 0xe3, 0x86, 0x32, 0x4e, 0xbe, 0x7f, 0x59, 0x07, 0x39, 0x81, 0xee, 0x74, 0xe9, 0x89, 0xcf, 0x23, 0x64, 0x78, 0x96, 0x06, 0x2d, 0x69, 0xb1, 0xb7, 0xe1, 0x3a, 0x2c, 0x83, 0x71, 0x9a, 0xef, 0xba, 0xb5, 0xab, 0xbe, 0x0b, 0xbe, 0x15, 0xaf, 0xcd, 0xc0, 0x2b, 0xee, 0x43, 0x90, 0x65, 0xde, 0x36, 0xab, 0x50, 0xfc, 0x29, 0x20, 0x63, 0xbe, 0xcb, 0x14, 0x4d, 0x8b, 0x6f, 0x55, 0x02, 0x41, 0x00, 0x97, 0x0a, 0x06, 0x36, 0xeb, 0xda, 0xa5, 0x90, 0x96, 0x82, 0x7f, 0x2b, 0x09, 0xbf, 0x38, 0x6c, 0x58, 0xf8, 0x85, 0x8b, 0xe0, 0xc0, 0x15, 0x97, 0xc8, 0x3a, 0x68, 0x31, 0xa8, 0x16, 0x5b, 0x3e, 0x34, 0x8d, 0x66, 0x6e, 0xce, 0x69, 0xec, 0xcd, 0x77, 0x04, 0x5b, 0xb0, 0x14, 0xc4, 0xa4, 0xa8, 0x56, 0xe0, 0x89, 0x2d, 0x99, 0x73, 0x36, 0xed, 0x5d, 0x39, 0xfe, 0xcd, 0x19, 0x6d, 0xac, 0xa5, 0x02, 0x41, 0x00, 0xfd, 0x96, 0x06, 0x45, 0x66, 0xdd, 0x1a, 0x86, 0x6d, 0x05, 0x63, 0x52, 0xe6, 0x2d, 0xef, 0x1d, 0x0a, 0xf4, 0x49, 0xda, 0x16, 0x1b, 0x0b, 0xe4, 0x95, 0x03, 0x8d, 0x73, 0x49, 0x25, 0x5b, 0x4b, 0xe5, 0x29, 0xb8, 0x21, 0x36, 0xaf, 0x1e, 0xfa, 0x9e, 0x8b, 0x6c, 0xcc, 0xa0, 0x02, 0x2d, 0xc4, 0xcc, 0x97, 0x29, 0x3e, 0xdd, 0x27, 0xe0, 0x2d, 0xcc, 0xd8, 0xd5, 0x48, 0x57, 0xa2, 0xd1, 0xbf};
static const unsigned char pycharmHash[]={0x47, 0xf5, 0x32, 0x45, 0xcd, 0x05, 0xa2, 0xb3, 0xe8, 0x11, 0xad, 0x65, 0x15, 0x00, 0x0b, 0x44, 0x60, 0x4b, 0x94, 0x7a, 0x57, 0xd4, 0x41, 0xb0, 0x21, 0x25, 0xb0, 0x4f, 0x4a, 0x16, 0xbb, 0x74};
/**
 * Creates a new UNIX FIFO file at |path_buf|, and opens it with |flags|.
 *
 * @return a file descriptor for the FIFO, or -1 if any syscall failed.
 */
static int open_fifo(char *path_buf, int flags) {
  int fifo_status = mkfifo(path_buf, 0644);
  if (fifo_status != 0) {
    if (errno == EEXIST) {
      fprintf(stderr, "GPIO: Reusing existing FIFO at %s\n", path_buf);
    } else {
      fprintf(stderr, "GPIO: Unable to create FIFO at %s: %s\n", path_buf,
              strerror(errno));
      return -1;
    }
  }

  int fd = open(path_buf, flags);
  if (fd < 0) {
    // Delete the fifo we created; ignore errors.
    unlink(path_buf);
    fprintf(stderr, "GPIO: Unable to open FIFO at %s: %s\n", path_buf,
            strerror(errno));
    return -1;
  }

  return fd;
}

/**
 * Print out a usage message for the GPIO interface.
 *
 * @arg rfifo the path to the "read" side (w.r.t the host).
 * @arg wfifo the path to the "write" side (w.r.t the host).
 * @arg n_bits the number of pins supported.
 */
static void print_usage(char *rfifo, char *wfifo, int n_bits) {
  printf("\n");
  printf(
      "GPIO: FIFO pipes created at %s (read) and %s (write) for %d-bit wide "
      "GPIO.\n",
      rfifo, wfifo, n_bits);
  printf(
      "GPIO: To measure the values of the pins as driven by the device, run\n");
  printf("$ cat %s  # '0' low, '1' high, 'X' floating\n", rfifo);
  printf("GPIO: To drive the pins, run a command like\n");
  printf("$ echo 'h09 l31' > %s  # Pull the pin 9 high, and pin 31 low.\n",
         wfifo);
}

void *gpiodpi_create(const char *name, int n_bits) {
  struct gpiodpi_ctx *ctx =
      (struct gpiodpi_ctx *)malloc(sizeof(struct gpiodpi_ctx));
  assert(ctx);

  // n_bits > 32 requires more sophisticated handling of svBitVecVal which we
  // currently don't do.
  assert(n_bits <= 32 && "n_bits must be <= 32");
  ctx->n_bits = n_bits;

  ctx->driven_pin_values = 0;

  char cwd_buf[PATH_MAX];
  char *cwd = getcwd(cwd_buf, sizeof(cwd_buf));
  assert(cwd != NULL);

  int path_len;
  path_len = snprintf(ctx->dev_to_host_path, PATH_MAX, "%s/%s-read", cwd, name);
  assert(path_len > 0 && path_len <= PATH_MAX);
  path_len =
      snprintf(ctx->host_to_dev_path, PATH_MAX, "%s/%s-write", cwd, name);
  assert(path_len > 0 && path_len <= PATH_MAX);

  ctx->dev_to_host_fifo = open_fifo(ctx->dev_to_host_path, O_RDWR);
  if (ctx->dev_to_host_fifo < 0) {
    return NULL;
  }

  ctx->host_to_dev_fifo = open_fifo(ctx->host_to_dev_path, O_RDWR);
  if (ctx->host_to_dev_fifo < 0) {
    return NULL;
  }

  int flags = fcntl(ctx->host_to_dev_fifo, F_GETFL, 0);
  fcntl(ctx->host_to_dev_fifo, F_SETFL, flags | O_NONBLOCK);

  print_usage(ctx->dev_to_host_path, ctx->host_to_dev_path, ctx->n_bits);

  return (void *)ctx;
}

void gpiodpi_device_to_host(void *ctx_void, svBitVecVal *gpio_data,
                            svBitVecVal *gpio_oe) {
  struct gpiodpi_ctx *ctx = (struct gpiodpi_ctx *)ctx_void;
  assert(ctx);

  // Write 0, 1, or X (when oe is not set) for each GPIO pin, in big endian
  // order (i.e., pin 0 is the last character written). Finish it with a
  // newline.
  char gpio_str[32 + 1];
  char *pin_char = gpio_str;
  for (int i = ctx->n_bits - 1; i >= 0; --i, ++pin_char) {
    if (!GET_BIT(gpio_oe[0], i)) {
      *pin_char = 'X';
    } else if (GET_BIT(gpio_data[0], i)) {
      *pin_char = '1';
    } else {
      *pin_char = '0';
    }
  }
  *pin_char = '\n';

  ssize_t written = write(ctx->dev_to_host_fifo, gpio_str, ctx->n_bits + 1);
  assert(written == ctx->n_bits + 1);
}

/**
 * Parses an unsigned decimal number from |text|, advancing it forward as
 * necessary.
 *
 * Returns upon encountering any non-decimal digit.
 */
static uint32_t parse_dec(char **text) {
  if (text == NULL || *text == NULL) {
    return 0;
  }

  uint32_t value = 0;
  for (; **text != '\0'; ++*text) {
    char c = **text;
    uint32_t digit;
    if (c >= '0' && c <= '9') {
      digit = (c - '0');
    } else {
      break;
    }

    value *= 10;
    value += digit;
  }

  return value;
}

uint32_t gpiodpi_host_to_device_tick(void *ctx_void, svBitVecVal *gpio_oe) {
  struct gpiodpi_ctx *ctx = (struct gpiodpi_ctx *)ctx_void;
  assert(ctx);

  char gpio_str[32 + 2];
  ssize_t read_len = read(ctx->host_to_dev_fifo, gpio_str, 32 + 1);
  if (read_len < 0) {
    return ctx->driven_pin_values;
  }
  //TEST SHA 256
  int i;
  unsigned char tmp[32];
  hash_state md;
  const char* message=(const char*)gpio_str;
  sha256_init(&md);
  sha256_process(&md, (unsigned char*)message, (unsigned long)XSTRLEN(message));
  sha256_done(&md, tmp);
  printf("\nHASH 256:");
  for(int i=0;i<32;++i){
    printf("%02x",tmp[i]);
  }
  printf("\n");


  //TEST RSA VERIFY
  ltc_mp = tfm_desc; //init tfm

  printf("\nBeginning test\n");
  unsigned char in[1024],out[1024];
  rsa_key       pubKey,privKey,pubTest,privTest;
  int           hash_idx,stat,err,prng_idx;
  unsigned long len,len2;
  if((hash_idx= register_hash(&sha256_desc)) != CRYPT_OK){
    printf("hash idx error: %d",hash_idx);
  }
  if ((prng_idx= register_prng(&yarrow_desc)) != CRYPT_OK){
    printf("prng idx error: %d",prng_idx);
  }
  //start yarrow prng;
  prng_state yr_state;
  yarrow_start(&yr_state);
  //activate prng
  yarrow_ready(&yr_state);
  unsigned char keyPubDER[1024];
  unsigned long keypubDERSize=sizeof(keyPubDER);
  printf("Proceeding to import public key\n");
  if ((err = rsa_import(pycharmPubKey, sizeof(pycharmPubKey),
                        &pubKey)) != CRYPT_OK) {
    printf("PUBLIC KEY import failed: %d\n", err);
  }
  //this is the one
  const char hexE[]="10001";
  const char hexN[]="d1e89e2bf8aa4486101dddbc16488d683c7af162f4ab648ec2560de0fdb519b4bf05cf43069a977c7d6cdeb3e6a4801b2f52cb938e4e137b73d5fdbe6a95e20ba5e3e3298090540d1c8172adf2bea65bb00cc7ca6043cf0e2221be777be6ec8c819057537e040f7578d82afbef04ea8951e8482407a357d6a4526d726f9f558f";
  const char hexD[]="bd68fb3950544c2af0e6124c838b0a5691a49aa6a182fae53b052dd6e4f882eeaf244de6fc5188fa63af56b1dd20791c8eb256529aa9673911c87a0455e753a56d088595d4bd8a02f08cddf0d55bcc42c27f2719b7db511d6147e72b832e78c734efa7acf0277a37cc40831a0c73a9ae29a04069b18a2f390c58a38134a64939";
  const char hexSignature[]="5d78f2ca125563d108656e72986724c2a0c211ae336b19875988fe62949c8cfec28b5defff5345d1216954894bd04a682978904f4f931212a2474d45b7def56d1e8e6f82de3c185c1862cf57cdecc3981f404503845ecf00c5e47ab37f891bdf1e7dfb7fb07dec6bcc65a10baf6a362e4a216d2c706c35d57b90a44eaa01592d";
  const char hexHash[]="47f53245cd05a2b3e811ad6515000b44604b947a57d441b02125b04f4a16bb74";

  unsigned char binE[128];
  unsigned char binN[257];
  unsigned char binD[257];
  unsigned char binSignature[300];
  unsigned char binHash[1024];

  unsigned long lenSignature;
  unsigned long lenbinE;
  unsigned long lenbinN;
  unsigned long lenbinD;
  unsigned long lenHash;

  lenbinE=sizeof(binE);
  lenbinN=sizeof(binN);
  lenbinD=sizeof(binD);
  lenSignature=sizeof(hexSignature);
  lenHash=sizeof(binHash);

  //hexadecimal to binary
  int radix_to_bin_e=radix_to_bin(hexE,16,binE,&lenbinE);
  printf("\nRadix to bin operation on E: %d\n",radix_to_bin_e);
  int radix_to_bin_N=radix_to_bin(hexN,16,binN,&lenbinN);
  printf("Radix to bin operation on N: %d\n",radix_to_bin_N);
  int radix_to_bin_D=radix_to_bin(hexD,16,binD,&lenbinD);
  printf("Radix to bin operation on D: %d\n",radix_to_bin_D);
  int radix_to_bin_Signature=radix_to_bin(hexSignature,16,binSignature,&lenSignature);
  printf("Radix to bin operation on signature: %d\n",radix_to_bin_Signature);
  int radix_to_bin_Hash=radix_to_bin(hexHash,16,binHash,&lenHash);
  printf("Radix to bin operation on hash: %d\n",radix_to_bin_Hash);

  //pubkey
  int rsa_set_pubkey_ret=rsa_set_key(binN,lenbinN,binE,lenbinE,NULL,NULL,&pubTest);
  printf("RSA Set pub Key ret: %d\n",rsa_set_pubkey_ret);
  //privkey
  int rsa_set_privkey_ret=rsa_set_key(binN,lenbinN,binE,lenbinE,binD,lenbinD,&privTest);
  printf("RSA Set priv Key ret: %d\n",rsa_set_privkey_ret);

  //sign hash
  unsigned char signatureTest[1024];
  unsigned long lenSignatureTest;
  lenSignatureTest=sizeof(signatureTest);
  int rsa_sign_hash_ret= rsa_sign_hash_ex(binHash,32,signatureTest,&lenSignatureTest,LTC_PKCS_1_PSS,&yr_state,prng_idx,hash_idx,0,&privTest);
  printf("sign hash ret: %d\n",rsa_sign_hash_ret);
  //verify hash
  int verify_hash= rsa_verify_hash_ex(signatureTest,lenSignatureTest,binHash,lenHash,LTC_PKCS_1_PSS,hash_idx,0,&stat,&pubTest);
  printf("Verify hash return: %d\n",verify_hash);
  printf("stat value: %d\n",stat);


  gpio_str[read_len] = '\0';

  char *gpio_text = gpio_str;
  for (; *gpio_text != '\0'; ++gpio_text) {
    switch (*gpio_text) {
      case '\n':
      case '\r':
      case '\0':
        goto parse_loop_end;
      case 'l':
      case 'L': {
        ++gpio_text;
        int idx = parse_dec(&gpio_text);
        if (!GET_BIT(gpio_oe[0], idx)) {
          fprintf(stderr,
                  "GPIO: Host tried to pull disabled pin low: pin %2d\n", idx);
        }
        CLR_BIT(ctx->driven_pin_values, idx);
        break;
      }
      case 'h':
      case 'H': {
        ++gpio_text;
        int idx = parse_dec(&gpio_text);
        if (!GET_BIT(gpio_oe[0], idx)) {
          fprintf(stderr,
                  "GPIO: Host tried to pull disabled pin high: pin %2d\n", idx);
        }
        SET_BIT(ctx->driven_pin_values, idx);
        break;
      }
      default:
        break;
    }
  }

parse_loop_end:
  return ctx->driven_pin_values;
}

void gpiodpi_close(void *ctx_void) {
  struct gpiodpi_ctx *ctx = (struct gpiodpi_ctx *)ctx_void;
  if (ctx == NULL) {
    return;
  }

  if (close(ctx->dev_to_host_fifo) != 0) {
    printf("GPIO: Failed to close FIFO file at %s: %s\n", ctx->dev_to_host_path,
           strerror(errno));
  }
  if (close(ctx->host_to_dev_fifo) != 0) {
    printf("GPIO: Failed to close FIFO file at %s: %s\n", ctx->host_to_dev_path,
           strerror(errno));
  }

  if (unlink(ctx->dev_to_host_path) != 0) {
    printf("GPIO: Failed to unlink FIFO file at %s: %s\n",
           ctx->dev_to_host_path, strerror(errno));
  }
  if (unlink(ctx->host_to_dev_path) != 0) {
    printf("GPIO: Failed to unlink FIFO file at %s: %s\n",
           ctx->host_to_dev_path, strerror(errno));
  }

  free(ctx);
}
